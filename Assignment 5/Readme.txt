Read Me

(i) as philosophers has  to use two fork left and right and to prevent the deadlock condition , so we declared LEFT (philosopher_id+4)%5 , and RIGHT (philosopher_id+1)%5 so that adjacent philosophers don't take forks to eat and we can prevent it from deadlock, so we create an array of philosopher of 5 size, and create it using pthread_create , first declared pthread_t thread_id1[5] and calling function philosopher, inside philosopher function , we had a loop of while(1) and having two functions picking_up_fork() and leave_fork() and inside taking fork(int philosopher_id) , first we are waiting sem_wait(&lock), first we declare sem_t lock, and sem_t S[5] , inside taking fork, we are calling check_1() and checking the state[phum] and state[philosopher_id]!=right and state[philosopher_id] !=left, so that fork took by philosophers are just adjacent, in this case philosophers are thinking, hungry and then eating the food .Similarly in putting fork, when the philosopher who took the fork , have done with eating he put down the fork, and similarly calling the function check_2()  and putting down the fork and at last compiling the file.


(ii) We have to modify the first part because here are 4 bowls and philosophers have access of single fork to eat , so i just done the above part again , but now i also make an array of bowls of 4 size, bowls[4] ={0,1,2,3}, so as the philosopher when take fork can eat the food in bowl and remaining philosophers do not have access the same bowl, so to prevent deadlock , made the bowls array, in that , state[philosopher_id]! =LEFT and state{philosopher_id]!=RIGHT where LEFT =(philosopher_id+4)%5  and RIGHT =(philosopher_id+1)%5 , so to prevent a deadlock.

(iii) we have 4 bowls and have 2 fork to eat, so similarly in 2nd part i took the consideration of 2nd part and in this case we have to be careful in taking 2 forks  and bowl  both , so here two functions bowls and fork function is used and i made two threads for bowl and the other one for fork pthread_t thread_id1[5] and pthread_t thread_id2[5]  , and doing the same process again and at last compiling the process.

